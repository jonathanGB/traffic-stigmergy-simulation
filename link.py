import numpy as np

"""
Represents a road link between two intersections.
Links are discretized into a matrix of cells. The number of rows is the number of lanes, and
the number of columns is the different places occupied by a car on a lane.
Every cell is represented as a Simpy resource with 1-capacity (so there's only one car per resource).
 env: Simpy environment
 out_intersections: Reference to the intersection at the end of the link
 cells: matrix of simpy.Resource
 edge: data about the edge (generated by the topology parser)...
  {
   "lanes": number of lanes,
   "l":     Euclidean length of the lane,
   "vmax":  maximum speed on the lane,
   "cells": number of cells in a lane,
   "cap":   capacity of the link (number of cells * number of lanes)
  }
 cache: stigmergy cache
"""
class Link:
  
  def __init__(self, env, cells, edge, cache):
    self.cells = cells
    self.cache = cache # holds stigmergy info for the lane
    self.env = env
    self.data = edge
    self.out_intersection = None # Nil, until set by the setter (Intersections are created after Links)

  def set_out_intersection(self, intersection):
    self.out_intersection = intersection

  def get_out_intersection(self):
    return self.out_intersection

  # TODO: add resource to the intersection, so there's a limited amount of cars at the same time
  # at the intersection?
  def access_intersection(self):
    return self.get_out_intersection()

  def request_entry(self):
    entry_cells = self.cells[:,0]

    for i, entry_cell in enumerate(entry_cells):
      if entry_cell.count == 0:
        return entry_cell, (i, 0)

    i = np.random.randint(0, self.data["lanes"])
    return entry_cells[i], (i, 0)

  def is_next_to_intersection(self, pos):
    return pos[1] == self.data["cells"] - 1

  def get_next_cell(self, pos):
    if self.is_next_to_intersection(pos):
      raise StopIteration("Can't get next cell: next is an intersection")

    nextPos = (pos[0], pos[1]+1)
    return self.cells[nextPos], nextPos

  """
  Returns the weight of this link.
  Current implementation only uses the number of cells 
  (which is proportionate to the time to traverse the link).
  Eventually, we'll want to involve stigmergy information.
  """
  def get_weight(self):
    return self.data["cells"]
